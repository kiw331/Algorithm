---------------------------------------------------------------------------------swea1859 백만장자

아이디어)
리스트에서 가장 비싼 날 찾기
그 전날까지 모두 구매후 당일에 팔기 - 손익 업데이트
다음 범위 찾기

        e = l.index(max(l[e:]))
리스트의 특정 범위값 내의 최대값을 찾고 그 인덱스를 알고 싶을때
(슬라이스 내부에서의 인덱스가 아니라 원본 리스트에서의 인덱스를)


---------------------------------------------------------------------------------boj2110 공유기설치

    idxs = [0, n-1].extend(i)
틀린표현 .extend의 반환값은 따로 없어서 idxs에는 None이 할당됨

l = [int(input()) for i in range(n)].sort()
마찬가지로 .sort()가 반환값이 없어서 l 에 None할당

l = [int(input()) for i in range(n)]
l.sort()

l = sorted([int(input()) for i in range(n)])

둘중에 하나로 고쳐야됨

---------------------------------------------------------------------------------etc/그리디01

문) 자연수 n, k 입력. n이 1이 될때 까지 k로 나누거나 -1
최소 수행 횟수 구하기

아이디어 - k가 2 이상이기만 하면 k로 나누는 작업이 -1 항상 빠르게 N을 줄일 수 있음

(집기술)
    t = (n // k) * k

 k로 나눠지는 수 중에 빼기로 만들수 있는 n과 가장 가까운 수 구하기
= n이 k로 나누어 떨어지는 수가 될때까지 빼기

(만약 +1도 가능했다면 t = round(n/k) * k )


---------------------------------------------------------------------------------swea1206 View


10
0 0 254 185 76 227 84 175 0 0

---------------------------------------------------------------------------------swea2056. 연월일 달력 

    tmp.extend(map(int, [s[:4],s[4:6],s[6:]]))

.extend( map(int, 리스트) )
리스트에 모든원소에 int함수 적용하고 extend하기

    print(*l[i], sep='/')
문자도 별 써서 출력됨, sep인자도 사용 가능

---------------------------------------------------------------------------------swea2072 홀수만 더하기

print(f'#{i+1}', sum(j for j in l[i] if j % 2 == 1))
sum()함수 안에 바로 리스트표현식 넣을 수 있음 ( []로 안 묶어도)

print('#', i+1, sum(j for j in l[i] if j % 2 == 1)) 
이렇게 작성하면 #랑 i+1 사이에 공백 발생

---------------------------------------------------------------------------------swea1954 달팽이 숫자

    for i in range(n):
        print(*arr[i])

[]없이 이차원 리스트 출력

---------------------------------------------------------------------------------boj1654 랜선자르기

*람다함수로 리스트의 모든 요소의 합 구하기
# 랜선길이가 p일때 랜선개수
def getcount(p):
    return sum(map(lambda x: x//p, l))

포인트) N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다.
5 5
300
300
300
300
100

여기서 정답은 150인데 최대 8개 까지도 만들수 있다.
기존 조건문대로

    # 랜선이 짧다. -> 위 범위 탐색
    elif count > n:

카운트의 개수가 5보다 크다고 계속 위범위만 탐색하게 하면 무한루프 발생

랜선길이p가 길다면 이분탐색을 하되, 짧을 경우에도 정답을 확인하는 절차( if getcount(p+1) < n: )가 필요
