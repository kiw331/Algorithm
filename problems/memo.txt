

---------------------------------------------------------------------------------boj1062 가르침



---------------------------------------------------------------------------------swea18799. 평균의 평균 D4



# 실수n이 정수인지 확인
f = 3.0
float(int(f)) == f

---------------------------------------------------------------------------------swea10965. 제곱수 만들기 D3

소인수분해


---------------------------------------------------------------------------------swea20019. 회문의 회문 D3

s = 'abcdefg'
뒤에서 부터 3개 슬라이싱

s[-3:]


3
hello
abcba
abacaba

---------------------------------------------------------------------------------swea20728. 공평한 분배 2 D3

정렬한 후에 슬라이싱으로 k개 원소 선택
리스트가 정렬되있으니까 max, min 필요없이 양쪽 인덱스끼리 빼면 최대값과 최소값의 차이임

3
3 2
1 2 3
3 3
5 20 10
4 3
4 3 2 1 
---------------------------------------------------------------------------------swea20021. 소수 그래프 D4 (실패)

그래프가 연결되어 있을 필요는 없다.???

아이디어 - 정점이 n개일 때 n보다 작은 소수들의 합으로 새로운 소수를 만들 수 있으면 가능하다??
-> 

가중치없는 무향그래프에서 간선의 최소개수는 n-1, 최대개수는 n(n-1)/2
다만 각 정점의 차수는 소수이고 총 간선수가 2*n이 될수는 없으므로 최소개수는 2*n+1 (3개, 2개, 2개...)


if not h: 리스트가 비어있는거 확인. 빈리스트는 False처럼 처리되지만
[] == False는 아님

그래프는 가중치 없는 무방향 그래프를 만들려고해.
간선의 총 개수는 소수(prime number)다.
모든 정점 차수(정점과 연결되어 있는 간선의 수)도 소수이다.
그래프가 연결되어 있을 필요는 없어

정점의 개수 n을 입력받았을 때 위 조건을 만족할는 그래프를 만들 수 있으면 1
없으면 -1을 출력하는 파이썬 코드를 만들어줘


---------------------------------------------------------------------------------swea1859 백만장자

아이디어)
리스트에서 가장 비싼 날 찾기
그 전날까지 모두 구매후 당일에 팔기 - 손익 업데이트
다음 범위 찾기

        e = l.index(max(l[e:]))
리스트의 특정 범위값 내의 최대값을 찾고 그 인덱스를 알고 싶을때
(슬라이스 내부에서의 인덱스가 아니라 원본 리스트에서의 인덱스를)


1
3
10 7 6

1
3
3 5 9
---------------------------------------------------------------------------------boj2110 공유기설치

    idxs = [0, n-1].extend(i)
틀린표현 .extend의 반환값은 따로 없어서 idxs에는 None이 할당됨

l = [int(input()) for i in range(n)].sort()
마찬가지로 .sort()가 반환값이 없어서 l 에 None할당

l = [int(input()) for i in range(n)]
l.sort()

l = sorted([int(input()) for i in range(n)])

둘중에 하나로 고쳐야됨

---------------------------------------------------------------------------------etc/그리디01

문) 자연수 n, k 입력. n이 1이 될때 까지 k로 나누거나 -1
최소 수행 횟수 구하기

아이디어 - k가 2 이상이기만 하면 k로 나누는 작업이 -1 항상 빠르게 N을 줄일 수 있음

(집기술)
    t = (n // k) * k

 k로 나눠지는 수 중에 빼기로 만들수 있는 n과 가장 가까운 수 구하기
= n이 k로 나누어 떨어지는 수가 될때까지 빼기

(만약 +1도 가능했다면 t = round(n/k) * k )


---------------------------------------------------------------------------------swea1206 View


10
0 0 254 185 76 227 84 175 0 0

---------------------------------------------------------------------------------swea2056. 연월일 달력 

    tmp.extend(map(int, [s[:4],s[4:6],s[6:]]))

.extend( map(int, 리스트) )
리스트에 모든원소에 int함수 적용하고 extend하기

    print(*l[i], sep='/')
문자도 별 써서 출력됨, sep인자도 사용 가능

---------------------------------------------------------------------------------swea2072 홀수만 더하기

print(f'#{i+1}', sum(j for j in l[i] if j % 2 == 1))
sum()함수 안에 바로 리스트표현식 넣을 수 있음 ( []로 안 묶어도)

print('#', i+1, sum(j for j in l[i] if j % 2 == 1)) 
이렇게 작성하면 #랑 i+1 사이에 공백 발생

---------------------------------------------------------------------------------swea1954 달팽이 숫자

    for i in range(n):
        print(*arr[i])

[]없이 이차원 리스트 출력

---------------------------------------------------------------------------------boj1654 랜선자르기

*람다함수로 리스트의 모든 요소의 합 구하기
# 랜선길이가 p일때 랜선개수
def getcount(p):
    return sum(map(lambda x: x//p, l))

포인트) N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다.
5 5
300
300
300
300
100

여기서 정답은 150인데 최대 8개 까지도 만들수 있다.
기존 조건문대로

    # 랜선이 짧다. -> 위 범위 탐색
    elif count > n:

카운트의 개수가 5보다 크다고 계속 위범위만 탐색하게 하면 무한루프 발생

랜선길이p가 길다면 이분탐색을 하되, 짧을 경우에도 정답을 확인하는 절차( if getcount(p+1) < n: )가 필요
