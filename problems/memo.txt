
---------------------------------------------------------------------------------boj6987_월드컵 g4

---------------------------------------------------------------------------------boj6987_월드컵 g4




---------------------------------------------------------------------------------boj15649 n과m(1) s3
백트래킹

아이디어)
리스트의 길이가 정해진 길이 M이 될때 까지 임시 리스트 tmp에 추가1부터 N까지의 원소 추가
원소를 추가하면 chk리스트에 방문표시해서 중복 원소가 안들어오도록
(조합이 아니라) 순열을 찾는거기 tmp내에서 같은 숫자가 들어오는거만 막으면 반복/재귀를 돌면서 중복 순열이 나올 일은 없음

---------------------------------------------------------------------------------swea1983 D2 성적매기기

학생의 점수 kg가 n(10의 배수)명일 때는 kidx등 이면 10명일 때는 몇등인가?

    kidx = round(k / (n // 10)) # 10등일 때 등수

    그냥 반올림하면 안됨

    ex) 30명중 7등이면 123 / 456 / 789 A-를 받아야함
    but 그냥 반올림 할경우 2.333등 -> 2등이 되서 A0를 받는다.
    따라서 천장함수 써서 무조건 올리는게 맞는 방법. 

---------------------------------------------------------------------------------swea1204 최빈수구하기 D2

점수가 1에서 100까지라는 제한이 있으므로 계수정렬할 때 처럼 '리스트의 인덱스 = 값'이되는 리스트를 만들 수 있음

    count = [0] * 101 
주의) 이때 count[100] +=1 연산이 되어야하니까 초기화 원소개수는 100이아닌 101개 



count.index(max(count)) 와 같이 하면 최대값 중 첫번째 인덱스가 구해지므로 
리스트에서 가장 큰수의 마지막 인덱스를 구하는 방법이 필요함.

last_index = len(count) - 1 - count[::-1].index(max_value)
리스트를 뒤집에서 뒤에서 부터 몇번째 있는지 구한다음 전체 길이에서 빼기

ex) 97이 최빈수 일때
count[::-1].index(max_value)은 3 (100, 99, 98, 97 - 4번째) 
101 - 1 -3 //97이 나오려면 1 더 빼야함




---------------------------------------------------------------------------------swea1244 최대상금 11.12
백트래킹

첫트 실패

https://www.youtube.com/watch?v=vGU8h1rneGw&t=18s
방법1. 
교환 횟수가 정해져 있기 때문에 가지치기(더 가봤자 갱신 못해)는 어려움

방법2. 중복방지
메모이제이션과 원리가 비슷

ex) 88832
반복문 특성상 낮은 인덱스는 나중에 교환이 안됨
    for i in range(L-1):
        for j in range(i+1, L):

0,1 번째 인덱스가 교환이 모두 끝나 88고정인 상태에서의 최대값을 모두 구했을 때
88??? 인 경우를 또 다시 고려할 필요가 없음

일반적인 백트래킹 문제와 차이점이 체크 표시를 가기전에 하는게 아니라 갔다 온다음에 하는것

//코드보고 다시 정리
같은 레벨, 같은 숫자의 경우 dfs를 중복해서 할 필요가 없음.







---------------------------------------------------------------------------------boj1062 가르침

22라인: com = set(com)에서 set()메소드 썼어야되는걸 2중 반복문에 넣어서 시간 초과



---------------------------------------------------------------------------------swea18799. 평균의 평균 D4



# 실수n이 정수인지 확인
f = 3.0
float(int(f)) == f

---------------------------------------------------------------------------------swea10965. 제곱수 만들기 D3

소인수분해


---------------------------------------------------------------------------------swea20019. 회문의 회문 D3

s = 'abcdefg'
뒤에서 부터 3개 슬라이싱

s[-3:]


3
hello
abcba
abacaba

---------------------------------------------------------------------------------swea20728. 공평한 분배 2 D3

정렬한 후에 슬라이싱으로 k개 원소 선택
리스트가 정렬되있으니까 max, min 필요없이 양쪽 인덱스끼리 빼면 최대값과 최소값의 차이임

3
3 2
1 2 3
3 3
5 20 10
4 3
4 3 2 1 
---------------------------------------------------------------------------------swea20021. 소수 그래프 D4 (실패)

그래프가 연결되어 있을 필요는 없다.???

아이디어 - 정점이 n개일 때 n보다 작은 소수들의 합으로 새로운 소수를 만들 수 있으면 가능하다??
-> 

가중치없는 무향그래프에서 간선의 최소개수는 n-1, 최대개수는 n(n-1)/2
다만 각 정점의 차수는 소수이고 총 간선수가 2*n이 될수는 없으므로 최소개수는 2*n+1 (3개, 2개, 2개...)


if not h: 리스트가 비어있는거 확인. 빈리스트는 False처럼 처리되지만
[] == False는 아님

그래프는 가중치 없는 무방향 그래프를 만들려고해.
간선의 총 개수는 소수(prime number)다.
모든 정점 차수(정점과 연결되어 있는 간선의 수)도 소수이다.
그래프가 연결되어 있을 필요는 없어

정점의 개수 n을 입력받았을 때 위 조건을 만족할는 그래프를 만들 수 있으면 1
없으면 -1을 출력하는 파이썬 코드를 만들어줘


---------------------------------------------------------------------------------swea1859 백만장자

아이디어)
리스트에서 가장 비싼 날 찾기
그 전날까지 모두 구매후 당일에 팔기 - 손익 업데이트
다음 범위 찾기

        e = l.index(max(l[e:]))
리스트의 특정 범위값 내의 최대값을 찾고 그 인덱스를 알고 싶을때
(슬라이스 내부에서의 인덱스가 아니라 원본 리스트에서의 인덱스를)


1
3
10 7 6

1
3
3 5 9
---------------------------------------------------------------------------------boj2110 공유기설치

    idxs = [0, n-1].extend(i)
틀린표현 .extend의 반환값은 따로 없어서 idxs에는 None이 할당됨

l = [int(input()) for i in range(n)].sort()
마찬가지로 .sort()가 반환값이 없어서 l 에 None할당

l = [int(input()) for i in range(n)]
l.sort()

l = sorted([int(input()) for i in range(n)])

둘중에 하나로 고쳐야됨

---------------------------------------------------------------------------------etc/그리디01

문) 자연수 n, k 입력. n이 1이 될때 까지 k로 나누거나 -1
최소 수행 횟수 구하기

아이디어 - k가 2 이상이기만 하면 k로 나누는 작업이 -1 항상 빠르게 N을 줄일 수 있음

(집기술)
    t = (n // k) * k

 k로 나눠지는 수 중에 빼기로 만들수 있는 n과 가장 가까운 수 구하기
= n이 k로 나누어 떨어지는 수가 될때까지 빼기

(만약 +1도 가능했다면 t = round(n/k) * k )


---------------------------------------------------------------------------------swea1206 View


10
0 0 254 185 76 227 84 175 0 0

---------------------------------------------------------------------------------swea2056. 연월일 달력 

    tmp.extend(map(int, [s[:4],s[4:6],s[6:]]))

.extend( map(int, 리스트) )
리스트에 모든원소에 int함수 적용하고 extend하기

    print(*l[i], sep='/')
문자도 별 써서 출력됨, sep인자도 사용 가능

---------------------------------------------------------------------------------swea2072 홀수만 더하기

print(f'#{i+1}', sum(j for j in l[i] if j % 2 == 1))
sum()함수 안에 바로 리스트표현식 넣을 수 있음 ( []로 안 묶어도)

print('#', i+1, sum(j for j in l[i] if j % 2 == 1)) 
이렇게 작성하면 #랑 i+1 사이에 공백 발생

---------------------------------------------------------------------------------swea1954 달팽이 숫자

n^2 공간을 만들고 빈공간을 -1로 표시
(0,0)에서 시작해서 우선 오른쪽 직선으로 나아가는데
범위를 넘어가거나, 빈공간이 아닐경우 방향 전환

[]없이 이차원 리스트 출력
    for i in range(n):
        print(*arr[i])


---------------------------------------------------------------------------------boj1654 랜선자르기

*람다함수로 리스트의 모든 요소의 합 구하기
# 랜선길이가 p일때 랜선개수
def getcount(p):
    return sum(map(lambda x: x//p, l))

포인트) N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다.
5 5
300
300
300
300
100

여기서 정답은 150인데 최대 8개 까지도 만들수 있다.
기존 조건문대로

    # 랜선이 짧다. -> 위 범위 탐색
    elif count > n:

카운트의 개수가 5보다 크다고 계속 위범위만 탐색하게 하면 무한루프 발생

랜선길이p가 길다면 이분탐색을 하되, 짧을 경우에도 정답을 확인하는 절차( if getcount(p+1) < n: )가 필요
