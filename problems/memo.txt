
---------------------------------------------------------------------------------boj3190_뱀 G4


---------------------------------------------------------------------------------boj2156_포도주


---------------------------------------------------------------------------------boj13914 숨바꼭질4 g4



---------------------------------------------------------------------------------boj14921_용액 합성하기
#투포인터

lst[s], lst[e] 양 끝에서 시작
lst[s] + lst[e]가 
양수면 e감소
음수면 s증가

---------------------------------------------------------------------------------swea13732 정사각형 판정 D3 (미완)

(이코테)[음료수 얼려먹기] dfs/bfs처럼 연결되는 영역 찾고 2개이상이면 no
찾은 영역이 정사각형인지 보면 될듯


---------------------------------------------------------------------------------swea8104. 조 만들기 D3

상태 이진변화?
not True

---------------------------------------------------------------------------------swea1984_중간평균값구하기 D2

내장 메소드 중에 평균 바로 구하는건 없음.

이 문제는 최대 최소값이 하나씩만 있다고 가정하고있는데
리스트에서 중복되는 값을 지울 때는

while x in a:
    a.remove(x)

---------------------------------------------------------------------------------swea22574 높은 곳으로 D3

폭탄이 없을 때는 항상 올라가는게 이득인가?
뒤에서 폭탄을 만나는거보다 낮은 층에서 쉬어가는게 나을 수 있다.

//풀다보니 그냥 반복으로 1~2^n개 모두 집어 넣고 같은 층

첫시도 백트래킹으로 모든 경우의 수를 따짐.
총 2^n개 경우의수 (ex n=3: 000전부대기, 100: 1번째만 이동, 010: 2번째만 이동 ...)
vst으로 기록해서 같은 선택(수), 같은 층이면 리턴

테케는 맞았는데 런타임 에러
n = 2000이면 재귀도 2천번 호출됨
RecursionError: maximum recursion depth exceeded in comparison
=> 재귀로 dfs구현하기 전에는 n값을 확인하자.

//반복문으로 다시 짜보자
최대값: 1로 채운 문자열

//trash garbage 문제. 의도한게 뭐였을까
폭탄은 하나니까 폭탄 만났을 때 1빼버리면됨

---------------------------------------------------------------------------------swea2005 파스칼의 삼각형 D2

010         현재 수열 양쪽에 0붙이기
11          0+1, 1+0 
0110        양쪽에 0
121         01 11 10
01210       양쪽에 0
    ...

---------------------------------------------------------------------------------swea2001_파리퇴치 d2

부분합으로 풀면 조금더 빠름

범위에 해당하는 숫자 더하는 중에 인덱스 설정 주의
첫번째 열을 포함한 범위의 수를 구할 때 (부분합 - 0) 을 할 수 있어야되므로 각 행의 첫번째 요소는 0
//풀면서 생각했는데 아예 행까지도 n+1개로 만들었으면 더 편했을거 같다.

    for i in range(n-m+1):
        for j in range(1,n-m+2):
            tmp = 0
            
            # (i,j)부터 m*m 영역의 수 모두 더하기
            for k in range(m):
                tmp += (bb[i+k][j+m-1] - bb[i+k][j-1])

j가 0부터 시작할때 의도치 않게 j[-1]이 대입되는거 주의

---------------------------------------------------------------------------------boj1309_동물원 s1

N번 째 줄에서 이전 사자위치를 고려해서 사자위치를 00, 10, 01(00은 배치 안하는거)에 놓는 방법 수
ex) N=2이고 사자 위치를 첫번째열에 사자를 배치하는 방법은 이전 배치가 00, 01 이였을 때 2가지

N   (사자위치) 
    00  10  01  합
1   1   1   1   3
2   3   2   2   7
3   7   5   5   17   
4               41

3행 까지 만들고 도출해낼 수 있는 점
an(00) = an-1
an(01) = an(10) 이고 an(01) = an-1(00) + an-1(10)

처음 풀때는 a_n = 2*a_n-1 + a_n-2 이렇게 풀었는데 왜 맞지?
다시 봤을 때 주석은 이해 안되는데 
https://great-park.tistory.com/131 같은 점화식을 세울수 있다.

boj1309_동물원 re


---------------------------------------------------------------------------------boj15649 n과m(1) s3
백트래킹

아이디어)
리스트의 길이가 정해진 길이 M이 될때 까지 임시 리스트 tmp에 추가1부터 N까지의 원소 추가
원소를 추가하면 chk리스트에 방문표시해서 중복 원소가 안들어오도록
(조합이 아니라) 순열을 찾는거기 tmp내에서 같은 숫자가 들어오는거만 막으면 반복/재귀를 돌면서 중복 순열이 나올 일은 없음



---------------------------------------------------------------------------------swea1983 D2 성적매기기

학생의 점수 kg가 n(10의 배수)명일 때는 kidx등 이면 10명일 때는 몇등인가?

    kidx = round(k / (n // 10)) # 10등일 때 등수

    그냥 반올림하면 안됨

    ex) 30명중 7등이면 123 / 456 / 789 A-를 받아야함
    but 그냥 반올림 할경우 2.333등 -> 2등이 되서 A0를 받는다.
    따라서 천장함수 써서 무조건 올리는게 맞는 방법. 

---------------------------------------------------------------------------------swea1204 최빈수구하기 D2

점수가 1에서 100까지라는 제한이 있으므로 계수정렬할 때 처럼 '리스트의 인덱스 = 값'이되는 리스트를 만들 수 있음

    count = [0] * 101 
주의) 이때 count[100] +=1 연산이 되어야하니까 초기화 원소개수는 100이아닌 101개 



count.index(max(count)) 와 같이 하면 최대값 중 첫번째 인덱스가 구해지므로 
리스트에서 가장 큰수의 마지막 인덱스를 구하는 방법이 필요함.

last_index = len(count) - 1 - count[::-1].index(max_value)
리스트를 뒤집에서 뒤에서 부터 몇번째 있는지 구한다음 전체 길이에서 빼기

ex) 97이 최빈수 일때
count[::-1].index(max_value)은 3 (100, 99, 98, 97 - 4번째) 
101 - 1 -3 //97이 나오려면 1 더 빼야함



---------------------------------------------------------------------------------swea1244 최대상금 11.12
백트래킹

첫트 실패

https://www.youtube.com/watch?v=vGU8h1rneGw&t=18s
방법1. 
교환 횟수가 정해져 있기 때문에 가지치기(더 가봤자 갱신 못해)는 어려움

방법2. 중복방지
메모이제이션과 원리가 비슷

ex) 88832
반복문 특성상 낮은 인덱스는 나중에 교환이 안됨
    for i in range(L-1):
        for j in range(i+1, L):

0,1 번째 인덱스가 교환이 모두 끝나 88고정인 상태에서의 최대값을 모두 구했을 때
88??? 인 경우를 또 다시 고려할 필요가 없음

일반적인 백트래킹 문제와 차이점이 체크 표시를 가기전에 하는게 아니라 갔다 온다음에 하는것

//코드보고 다시 정리
같은 레벨, 같은 숫자의 경우 dfs를 중복해서 할 필요가 없음.







---------------------------------------------------------------------------------boj1062 가르침

22라인: com = set(com)에서 set()메소드 썼어야되는걸 2중 반복문에 넣어서 시간 초과



---------------------------------------------------------------------------------swea18799. 평균의 평균 D4



# 실수n이 정수인지 확인
f = 3.0
float(int(f)) == f

---------------------------------------------------------------------------------swea10965. 제곱수 만들기 D3

소인수분해


---------------------------------------------------------------------------------swea20019. 회문의 회문 D3

s = 'abcdefg'
뒤에서 부터 3개 슬라이싱

s[-3:]


3
hello
abcba
abacaba

---------------------------------------------------------------------------------swea20728. 공평한 분배 2 D3

정렬한 후에 슬라이싱으로 k개 원소 선택
리스트가 정렬되있으니까 max, min 필요없이 양쪽 인덱스끼리 빼면 최대값과 최소값의 차이임

3
3 2
1 2 3
3 3
5 20 10
4 3
4 3 2 1 

s와 e의 거리를 k만큼 유지할 채로 모든 경우를 비교

---------------------------------------------------------------------------------swea20021. 소수 그래프 D4 (실패)

그래프가 연결되어 있을 필요는 없다.???

아이디어 - 정점이 n개일 때 n보다 작은 소수들의 합으로 새로운 소수를 만들 수 있으면 가능하다??
-> 

가중치없는 무향그래프에서 간선의 최소개수는 n-1, 최대개수는 n(n-1)/2
다만 각 정점의 차수는 소수이고 총 간선수가 2*n이 될수는 없으므로 최소개수는 2*n+1 (3개, 2개, 2개...)


if not h: 리스트가 비어있는거 확인. 빈리스트는 False처럼 처리되지만
[] == False는 아님

그래프는 가중치 없는 무방향 그래프를 만들려고해.
간선의 총 개수는 소수(prime number)다.
모든 정점 차수(정점과 연결되어 있는 간선의 수)도 소수이다.
그래프가 연결되어 있을 필요는 없어

정점의 개수 n을 입력받았을 때 위 조건을 만족할는 그래프를 만들 수 있으면 1
없으면 -1을 출력하는 파이썬 코드를 만들어줘


---------------------------------------------------------------------------------swea1859 백만장자

아이디어)
리스트에서 가장 비싼 날 찾기
그 전날까지 모두 구매후 당일에 팔기 - 손익 업데이트
다음 범위 찾기

        e = l.index(max(l[e:]))
리스트의 특정 범위값 내의 최대값을 찾고 그 인덱스를 알고 싶을때
(슬라이스 내부에서의 인덱스가 아니라 원본 리스트에서의 인덱스를)


1
3
10 7 6

1
3
3 5 9
---------------------------------------------------------------------------------boj2110 공유기설치

    idxs = [0, n-1].extend(i)
틀린표현 .extend의 반환값은 따로 없어서 idxs에는 None이 할당됨

l = [int(input()) for i in range(n)].sort()
마찬가지로 .sort()가 반환값이 없어서 l 에 None할당

l = [int(input()) for i in range(n)]
l.sort()

l = sorted([int(input()) for i in range(n)])

둘중에 하나로 고쳐야됨

---------------------------------------------------------------------------------etc/그리디01

문) 자연수 n, k 입력. n이 1이 될때 까지 k로 나누거나 -1
최소 수행 횟수 구하기

아이디어 - k가 2 이상이기만 하면 k로 나누는 작업이 -1 항상 빠르게 N을 줄일 수 있음

(집기술)
    t = (n // k) * k

 k로 나눠지는 수 중에 빼기로 만들수 있는 n과 가장 가까운 수 구하기
= n이 k로 나누어 떨어지는 수가 될때까지 빼기

(만약 +1도 가능했다면 t = round(n/k) * k )


---------------------------------------------------------------------------------swea1206 View


10
0 0 254 185 76 227 84 175 0 0

---------------------------------------------------------------------------------swea2056. 연월일 달력 

    tmp.extend(map(int, [s[:4],s[4:6],s[6:]]))

.extend( map(int, 리스트) )
리스트에 모든원소에 int함수 적용하고 extend하기

    print(*l[i], sep='/')
문자도 별 써서 출력됨, sep인자도 사용 가능

---------------------------------------------------------------------------------swea2072 홀수만 더하기

print(f'#{i+1}', sum(j for j in l[i] if j % 2 == 1))
sum()함수 안에 바로 리스트표현식 넣을 수 있음 ( []로 안 묶어도)

print('#', i+1, sum(j for j in l[i] if j % 2 == 1)) 
이렇게 작성하면 #랑 i+1 사이에 공백 발생

---------------------------------------------------------------------------------swea1954 달팽이 숫자

n^2 공간을 만들고 빈공간을 -1로 표시
(0,0)에서 시작해서 우선 오른쪽 직선으로 나아가는데
범위를 넘어가거나, 빈공간이 아닐경우 방향 전환

[]없이 이차원 리스트 출력
    for i in range(n):
        print(*arr[i])


---------------------------------------------------------------------------------boj1654 랜선자르기

*람다함수로 리스트의 모든 요소의 합 구하기
# 랜선길이가 p일때 랜선개수
def getcount(p):
    return sum(map(lambda x: x//p, l))

포인트) N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다.
5 5
300
300
300
300
100

여기서 정답은 150인데 최대 8개 까지도 만들수 있다.
기존 조건문대로

    # 랜선이 짧다. -> 위 범위 탐색
    elif count > n:

카운트의 개수가 5보다 크다고 계속 위범위만 탐색하게 하면 무한루프 발생

랜선길이p가 길다면 이분탐색을 하되, 짧을 경우에도 정답을 확인하는 절차( if getcount(p+1) < n: )가 필요
