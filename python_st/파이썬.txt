

---------------------------------------------------------------------------파이썬

블록주석: 드래그 하고 '''


최대값으로 결과 갱신할 때는 max함수보다 조건문 이용하는게 더 빠르다

res = max(res, tmp)

if tmp > res:
	res = tmp

---------------------------------------------------------------------------쉽배알

▶그래프 표현

1)인접행렬
이차원 배열로 노드 사이의 간선 포현
간선 존재 여부를 바로 알 수 있으나 행렬을 채우는데만 n^2의 시간이 들고 공간낭비가 심할 수 있음
간서의 밀도가 높은 그래프에 적합

무향그래프는 대칭형태

2)인접리스트
인접한 정점을 리스트로 표현
공간의 낭비는 없으나 간선 존재 여부 알아보는데 (인접행렬보다) 시간소요

---------------------------------------------------------------------------이코테

라이브러리
itertools: 순열, 조합 등
heapq: 힙-우선순위큐
bisect: 이진탐색
collections
math

(1) 그리디
거스름돈 문제, 

(2) 구현
풀이를 떠올리는건 쉽지만 소스코드로 옮기기 어려운 문제

시뮬레이션 - 방향벡터

(3)DFS, BFS
그래프 탐색

▪DFS 스택/재귀함수 활용
현재 노드에 인접 노드(하나)를 스택에 넣고 방문처리
현재노드에서 방문하지 않은 인접노드가 없을 때는 pop
최상단 노드에 대해 동일 작업 수행


▪BFS 큐활용(deque[덱])
시작노드를 큐에 삽입하고 방문처리
큐에서 꺼낸 노드와 인접한 노드 중 방문하지 않은 노드를 '모두' 큐에 넣고 방문처리

*간선의비용이 모두 같을 때 = 가중치가 없을 때 최단거리 탐색에 활용가능

(4) 정렬

▪선택정렬
리스트에서 	가장 작은 수를 인덱스0 위치의 수와 변경
나머지 리스트에서 	가장 작은 수를 인덱스 1 위치의 수와 변경
...
n-1번 수행 (마지막 수는 가장 큰수니까 변경할 필요 없음.)
O(n^2)

▪삽입정렬
첫번째 데이터(인데스0)은 정렬 되있다고 가정하고
arr[1] 부터 삽입될 위치를 고르기
-바로 왼쪽에 있는 데이터와 비교하면서 자기보다 작은 데이터를 만날 때 까지 왼쪽으로 이동

O(N^2) but 최선의 경우 O(N)
현재 리스트가 거의 정렬되어 있다면 적절함

▪계수정렬
데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용 가능

가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있도록 배열생성
배열의 인덱스는 데이터의 값에 해당
데이터를 하나씩 읽어서 동일한 인덱스의 데이터를 1씩 증가 - 각 데이터가 등장 횟수

O(N^2), 공간 낭비 초래할 수 있음, 데이터의 범위가 크지 않고 동일한 값을 가지는 데이터가 여러개 등장할 때 효율적


(5) 동적 프로그래밍
이미 계산된 결과를 별도로 저장했다가, 그 결과가 필요할 때 그대로 사용 (중복 계산을 방지)

탑다운 / 바텀업 2가지 방식
조건) 최적부분구조, 중복되는문제








