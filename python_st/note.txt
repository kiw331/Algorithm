

---------------------------------------------------------------------------수학기믹

▶소수 판별 
a * b = n 일때 a,b가 루트n이 아니라면
a < sqrt(n) < b 이러식으로 n의 루트값 양쪽에 하나씩 존재할 수 밖에 없음
즉, 숫자 n이 소수인지 판별하기 위해선 (2부터 n-1까지가 아니라) n의 제곱근 까지만 나눠봐도 알 수 있음

▶유클리드 호제법: 최대공약수 구하기
a, b의 최대 공약수는
a%b, b의 공약수와 같다 (단, a>b),


---------------------------------------------------------------------------파이썬

블록주석: 드래그 하고 '''


▶최대값으로 결과 갱신할 때는 max함수보다 조건문 이용하는게 더 빠르다

res = max(res, tmp)

if tmp > res:
	res = tmp

+
res = tmp if tmp > res

▶global
전역변수를 사용자 정의함수에서 수정하려면 global키워드를 써야되지만 리스트는 불필요함
'리스트는 가변 객체이므로, 함수 내에서 직접 요소를 변경하는 것은 전역 리스트에 바로 영향을 미칩니다.'


---------------------------------------------------------------------------코딩테스트 알고리즘 - 3. 백트래킹
https://www.youtube.com/watch?v=atTzqxbt4DM 
(개발자 장고)

백트래킹
-모든 경우의 수를 확인해야 하는 경우
-for로는 확인 불가한 경우(for문은 정해진 깊이 까지만 확인할 수 있기 때문)

트리가 전개되는 방식과 유사함. 재귀로 구현
재귀함수가 호출 되는건 깊이 증가, 재귀함수안의 for문 - 형제노드로 이동

*재귀, DP와 차이점은?

[예시문제: 백준15694 N과 M ]
자연수 1부터 N사이에서 중복없이 M개를 고른 순열

시간복잡도
중복이 가능할 때 N^N (N=8개 까지 가능)
중복이 불가능할 때 N! (N=10개 까지 가능)

아이디어)
리스트의 길이가 정해진 길이 M이 될때 까지 임시 리스트 tmp에 추가1부터 N까지의 원소 추가
원소를 추가하면 chk리스트에 방문표시해서 중복 원소가 안들어오도록
(조합이 아니라) 순열을 찾는거기 tmp내에서 같은 숫자가 들어오는거만 막으면 반복/재귀를 돌면서 중복 순열이 나올 일은 없음

Tip
백트래킹 문제는 N이 작음
재귀함수 사용할 때 종료시점 잊지말기



---------------------------------------------------------------------------쉽배알

▶그래프 표현

1)인접행렬
이차원 배열로 노드 사이의 간선 포현
간선 존재 여부를 바로 알 수 있으나 행렬을 채우는데만 n^2의 시간이 들고 공간낭비가 심할 수 있음
간서의 밀도가 높은 그래프에 적합

무향그래프는 대칭형태

2)인접리스트
인접한 정점을 리스트로 표현
공간의 낭비는 없으나 간선 존재 여부 알아보는데 (인접행렬보다) 시간소요

---------------------------------------------------------------------------이코테

라이브러리
itertools: 순열, 조합 등
heapq: 힙-우선순위큐
bisect: 이진탐색
collections
math: sqrt, ceil, floor

(2) 그리디 & 구현

▪그리디
현재 상황에서 가장 많은 이득을 취하는 작업이 최적의 해를 보장한다는 '정당성 분석'이 필요

[거스름돈 문제]: 거슬러 주어야할 동전의 최소 개수
단순히 큰 화폐를 거슬러 주는게 최적의 해를 보장하는 이유는?
큰 단위가 작은 단위의 배수 이기 때문 

[1이 될때까지]: 1을 빼거나 k로 나누거나
k가 2이상이기만하면 1을 빼는거보단 훨씬 많은 값을 줄일 수 있음.
-> 나누어 떨어질때는 무조건 나누기

[곱하기 혹은 더하기]

[모험가 길드] 공포도가 x인 모험가는 x명 이상인 그룹에 참여할 수 있음. 만들 수 있는 그룹 수의 최대값
오름 차순 정렬 이후에 앞에서 부터 공포도를 확인하여 모험가수 > 공포도 이면 하나의 그룹으로 만들 수 있음
공포도가 오름차순으로 정렬되어 있기 때문에 항상 최소한의 모험가의 수가 포함됨.

▪구현
풀이를 떠올리는건 쉽지만 소스코드로 옮기기 어려운 문제

시뮬레이션 - 방향벡터
[시각] 3이 포함되어있는 시각 모두 세기. 완전탐색 유형
[왕실의 나이트] 체스판
[문자열 재정렬] 


(3)DFS, BFS
그래프 탐색

▪스택 
리스트 자료형 사용

▪큐
collections의 deque
리스트로 구현할 수 있지만 시간복잡도가 높아짐 
(리스트에서 popleft하게되면 원소의 위치를 조정하는 과정 필요)


▪DFS 스택/재귀함수 활용
현재 노드에 인접 노드(하나)를 스택에 넣고 방문처리
현재노드에서 방문하지 않은 인접노드가 없을 때는 pop
최상단 노드에 대해 동일 작업 수행

//구현할때 스택은 안쓰네

▪BFS 큐활용(deque[덱])
시작노드를 큐에 삽입하고 방문처리
큐에서 꺼낸 노드와 인접한 노드 중 방문하지 않은 노드를 '모두' 큐에 넣고 방문처리

파이썬 구현 시
queue.popleft()

*BFS:간선의비용이 모두 같을 때 (= 가중치가 없을 때) 최단거리 탐색에 활용가능

[음료수 얼려 먹기] - 연결 요소 구하기
DFS/BFS를 통한 연결 요소 구하기. 연결 노드를 그래프로 표현

[미로탈출]
간선이 비용이 모두 같음(비용이 따로 안나와있음)
시작점에서 모든 노드에 대한 최단거리 값을 기록


(4) 정렬

▪선택정렬
리스트에서 	가장 작은 수를 인덱스0 위치의 수와 변경
나머지 리스트에서 	가장 작은 수를 인덱스 1 위치의 수와 변경
...
n-1번 수행 (마지막 수는 가장 큰수니까 변경할 필요 없음.)
O(n^2)

▪삽입정렬
첫번째 데이터(인데스0)은 정렬 되있다고 가정하고
arr[1] 부터 삽입될 위치를 고르기
-바로 왼쪽에 있는 데이터와 비교하면서 자기보다 작은 데이터를 만날 때 까지 왼쪽으로 이동

O(N^2) but 최선의 경우 O(N)
현재 리스트가 거의 정렬되어 있다면 적절함

▪계수정렬
데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용 가능

가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있도록 배열생성
배열의 인덱스는 데이터의 값에 해당
데이터를 하나씩 읽어서 동일한 인덱스의 데이터를 1씩 증가 - 각 데이터가 등장 횟수

O(N^2), 공간 낭비 초래할 수 있음, 데이터의 범위가 크지 않고 동일한 값을 가지는 데이터가 여러개 등장할 때 효율적

(5) 이진탐색

(6) 동적 프로그래밍
이미 계산된 결과를 별도로 저장했다가, 그 결과가 필요할 때 그대로 사용 (중복 계산을 방지)

탑다운 / 바텀업 2가지 방식
▪탑다운(하향식, 메모이제이션, 캐싱)
-재귀함수 사용

▪바텀업(상향식)
-반복문


조건) 
최적부분구조: 큰 문제를 작은문제로 나눌 수 있고 작은 문제의 답을 모아서 큰 문제를 해결
중복되는문제

*vs 분할정복
분할정복도 최적부분구조가질 때 사용할 수 있지만 부분문제의 중복은 없음.

-최대한 많은 포도주, 식량 고르기
-연산 횟수를 최소화 해서 1로 나누기(그리디 안될 경우)
-m원을 만들기 위한 최소한의 화폐 개수
-금광문제 거처가는 위치에 따라 얻을 수 있는 금의 최대 크기(포도주랑 비슷)
-병사배치하기: 남아있는 병사 수가 최대가 되도록 열외 시키기(최소한으로 열외시키기)
	-가장 긴 증가하는 부분 수열 LIS: D[i] = max(D[i], D[j]+1) if arr[i] > arr[j] //+되야되는거 아님?
	:i번째 원소와 이전 원소들의 비교하며 원소들 중에서 i번째 원소보다 작은 원소들 중 DP값이 가장 큰 값에 + 1을 하여 dp[i]의 값을 구합니다.
	: DP테이블에 남아있는 값중 최대값
...

(7) 최단경로
▪다익스트라 - 음의 가중치를 갖는 간선이 없을 때
-매 상황에서 가장 비용이 적은 노드를 선택(그리디로 분류하기도 함)

(8) 기타 그래프 이론


(9) 빈출 문제











